{"ast":null,"code":"var _jsxFileName = \"E:\\\\EMS\\\\frontend\\\\src\\\\context\\\\AuthContext.jsx\",\n  _s = $RefreshSig$();\nimport { createContext, useState, useEffect, useCallback } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const AuthContext = /*#__PURE__*/createContext();\nconst TOKEN_KEY = process.env.REACT_APP_TOKEN_KEY || \"auth_token\";\n\n// Safely access localStorage\nconst getLocalStorage = () => {\n  if (typeof window !== \"undefined\" && window.localStorage) {\n    return window.localStorage;\n  }\n  return null;\n};\n\n// Parse JWT token\nconst parseJwt = token => {\n  try {\n    const base64Url = token.split('.')[1];\n    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n    const jsonPayload = decodeURIComponent(atob(base64).split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));\n    return JSON.parse(jsonPayload);\n  } catch (error) {\n    console.error('Error parsing JWT token:', error);\n    return null;\n  }\n};\n\n// Check if token is expired\nconst isTokenExpired = token => {\n  try {\n    const decoded = parseJwt(token);\n    if (!decoded || !decoded.exp) return true;\n    const currentTime = Math.floor(Date.now() / 1000);\n    return decoded.exp < currentTime;\n  } catch (error) {\n    console.error('Error checking token expiration:', error);\n    return true;\n  }\n};\nexport function AuthProvider({\n  children\n}) {\n  _s();\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n  // Initialize auth on mount\n  useEffect(() => {\n    const storage = getLocalStorage();\n    if (storage) {\n      const token = storage.getItem(TOKEN_KEY);\n      if (token && !isTokenExpired(token)) {\n        const decodedToken = parseJwt(token);\n        if (decodedToken) {\n          let role = (decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.role) || 'EMPLOYEE';\n          // Backend sends role without ROLE_ prefix, but frontend expects it for consistency\n          // Store both formats for compatibility\n          const roleWithPrefix = role.startsWith('ROLE_') ? role : `ROLE_${role}`;\n          const userData = {\n            token,\n            username: decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.sub,\n            role: roleWithPrefix,\n            // Store with ROLE_ prefix for frontend checks\n            originalRole: role,\n            // Store original role from backend\n            id: (decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.userId) || (decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.id),\n            email: decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.email\n          };\n          setUser(userData);\n          setIsAuthenticated(true);\n          // Also store user data in localStorage for services that need it\n          storage.setItem('user', JSON.stringify(userData));\n        } else {\n          storage.removeItem(TOKEN_KEY);\n          storage.removeItem('user');\n        }\n      } else if (token && isTokenExpired(token)) {\n        storage.removeItem(TOKEN_KEY);\n        storage.removeItem('user');\n      }\n    }\n    setLoading(false);\n  }, []);\n\n  // Auto logout if token expires\n  useEffect(() => {\n    if (!(user !== null && user !== void 0 && user.token)) return;\n    const interval = setInterval(() => {\n      if (isTokenExpired(user.token)) {\n        logout();\n      }\n    }, 60000);\n    return () => clearInterval(interval);\n  }, [user]);\n  const login = useCallback(token => {\n    const storage = getLocalStorage();\n    if (storage) storage.setItem(TOKEN_KEY, token);\n    const decodedToken = parseJwt(token);\n    if (decodedToken) {\n      let role = (decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.role) || 'EMPLOYEE';\n      // Backend sends role without ROLE_ prefix, but frontend expects it for consistency\n      // Store both formats for compatibility\n      const roleWithPrefix = role.startsWith('ROLE_') ? role : `ROLE_${role}`;\n      const userData = {\n        token,\n        username: decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.sub,\n        role: roleWithPrefix,\n        // Store with ROLE_ prefix for frontend checks\n        originalRole: role,\n        // Store original role from backend\n        id: (decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.userId) || (decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.id),\n        email: decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.email\n      };\n      setUser(userData);\n      setIsAuthenticated(true);\n\n      // Also store user data in localStorage for services that need it\n      storage.setItem('user', JSON.stringify(userData));\n      return userData;\n    } else {\n      throw new Error('Invalid token format');\n    }\n  }, []);\n  const logout = useCallback(() => {\n    const storage = getLocalStorage();\n    if (storage) {\n      storage.removeItem(TOKEN_KEY);\n      storage.removeItem('user');\n    }\n    setUser(null);\n    setIsAuthenticated(false);\n  }, []);\n  const hasRole = useCallback(role => (user === null || user === void 0 ? void 0 : user.role) === role, [user]);\n  const hasAnyRole = useCallback(roles => roles.includes(user === null || user === void 0 ? void 0 : user.role), [user]);\n  const updateUser = useCallback(userData => {\n    if (user) setUser(prev => ({\n      ...prev,\n      ...userData\n    }));\n  }, [user]);\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: {\n      user,\n      loading,\n      isAuthenticated,\n      login,\n      logout,\n      hasRole,\n      hasAnyRole,\n      updateUser\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 145,\n    columnNumber: 9\n  }, this);\n}\n_s(AuthProvider, \"W2gIJvmxkHFvjGaWPG60xnyIH1k=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["createContext","useState","useEffect","useCallback","jsxDEV","_jsxDEV","AuthContext","TOKEN_KEY","process","env","REACT_APP_TOKEN_KEY","getLocalStorage","window","localStorage","parseJwt","token","base64Url","split","base64","replace","jsonPayload","decodeURIComponent","atob","map","c","charCodeAt","toString","slice","join","JSON","parse","error","console","isTokenExpired","decoded","exp","currentTime","Math","floor","Date","now","AuthProvider","children","_s","user","setUser","loading","setLoading","isAuthenticated","setIsAuthenticated","storage","getItem","decodedToken","role","roleWithPrefix","startsWith","userData","username","sub","originalRole","id","userId","email","setItem","stringify","removeItem","interval","setInterval","logout","clearInterval","login","Error","hasRole","hasAnyRole","roles","includes","updateUser","prev","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["E:/EMS/frontend/src/context/AuthContext.jsx"],"sourcesContent":["import { createContext, useState, useEffect, useCallback } from \"react\";\r\n\r\nexport const AuthContext = createContext();\r\n\r\nconst TOKEN_KEY = process.env.REACT_APP_TOKEN_KEY || \"auth_token\";\r\n\r\n// Safely access localStorage\r\nconst getLocalStorage = () => {\r\n    if (typeof window !== \"undefined\" && window.localStorage) {\r\n        return window.localStorage;\r\n    }\r\n    return null;\r\n};\r\n\r\n// Parse JWT token\r\nconst parseJwt = (token) => {\r\n    try {\r\n        const base64Url = token.split('.')[1];\r\n        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\r\n        const jsonPayload = decodeURIComponent(\r\n            atob(base64).split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join('')\r\n        );\r\n        return JSON.parse(jsonPayload);\r\n    } catch (error) {\r\n        console.error('Error parsing JWT token:', error);\r\n        return null;\r\n    }\r\n};\r\n\r\n// Check if token is expired\r\nconst isTokenExpired = (token) => {\r\n    try {\r\n        const decoded = parseJwt(token);\r\n        if (!decoded || !decoded.exp) return true;\r\n        const currentTime = Math.floor(Date.now() / 1000);\r\n        return decoded.exp < currentTime;\r\n    } catch (error) {\r\n        console.error('Error checking token expiration:', error);\r\n        return true;\r\n    }\r\n};\r\n\r\nexport function AuthProvider({ children }) {\r\n    const [user, setUser] = useState(null);\r\n    const [loading, setLoading] = useState(true);\r\n    const [isAuthenticated, setIsAuthenticated] = useState(false);\r\n\r\n    // Initialize auth on mount\r\n    useEffect(() => {\r\n        const storage = getLocalStorage();\r\n        if (storage) {\r\n            const token = storage.getItem(TOKEN_KEY);\r\n            if (token && !isTokenExpired(token)) {\r\n                const decodedToken = parseJwt(token);\r\n                if (decodedToken) {\r\n                    let role = decodedToken?.role || 'EMPLOYEE';\r\n                    // Backend sends role without ROLE_ prefix, but frontend expects it for consistency\r\n                    // Store both formats for compatibility\r\n                    const roleWithPrefix = role.startsWith('ROLE_') ? role : `ROLE_${role}`;\r\n                    const userData = {\r\n                        token,\r\n                        username: decodedToken?.sub,\r\n                        role: roleWithPrefix, // Store with ROLE_ prefix for frontend checks\r\n                        originalRole: role, // Store original role from backend\r\n                        id: decodedToken?.userId || decodedToken?.id,\r\n                        email: decodedToken?.email\r\n                    };\r\n                    setUser(userData);\r\n                    setIsAuthenticated(true);\r\n                    // Also store user data in localStorage for services that need it\r\n                    storage.setItem('user', JSON.stringify(userData));\r\n                } else {\r\n                    storage.removeItem(TOKEN_KEY);\r\n                    storage.removeItem('user');\r\n                }\r\n            } else if (token && isTokenExpired(token)) {\r\n                storage.removeItem(TOKEN_KEY);\r\n                storage.removeItem('user');\r\n            }\r\n        }\r\n        setLoading(false);\r\n    }, []);\r\n\r\n    // Auto logout if token expires\r\n    useEffect(() => {\r\n        if (!user?.token) return;\r\n\r\n        const interval = setInterval(() => {\r\n            if (isTokenExpired(user.token)) {\r\n                logout();\r\n            }\r\n        }, 60000);\r\n\r\n        return () => clearInterval(interval);\r\n    }, [user]);\r\n\r\n    const login = useCallback((token) => {\r\n        const storage = getLocalStorage();\r\n        if (storage) storage.setItem(TOKEN_KEY, token);\r\n\r\n        const decodedToken = parseJwt(token);\r\n        if (decodedToken) {\r\n            let role = decodedToken?.role || 'EMPLOYEE';\r\n            // Backend sends role without ROLE_ prefix, but frontend expects it for consistency\r\n            // Store both formats for compatibility\r\n            const roleWithPrefix = role.startsWith('ROLE_') ? role : `ROLE_${role}`;\r\n\r\n            const userData = {\r\n                token,\r\n                username: decodedToken?.sub,\r\n                role: roleWithPrefix, // Store with ROLE_ prefix for frontend checks\r\n                originalRole: role, // Store original role from backend\r\n                id: decodedToken?.userId || decodedToken?.id,\r\n                email: decodedToken?.email\r\n            };\r\n            setUser(userData);\r\n            setIsAuthenticated(true);\r\n            \r\n            // Also store user data in localStorage for services that need it\r\n            storage.setItem('user', JSON.stringify(userData));\r\n            \r\n            return userData;\r\n        } else {\r\n            throw new Error('Invalid token format');\r\n        }\r\n    }, []);\r\n\r\n    const logout = useCallback(() => {\r\n        const storage = getLocalStorage();\r\n        if (storage) {\r\n            storage.removeItem(TOKEN_KEY);\r\n            storage.removeItem('user');\r\n        }\r\n        setUser(null);\r\n        setIsAuthenticated(false);\r\n    }, []);\r\n\r\n    const hasRole = useCallback((role) => user?.role === role, [user]);\r\n    const hasAnyRole = useCallback((roles) => roles.includes(user?.role), [user]);\r\n    const updateUser = useCallback((userData) => {\r\n        if (user) setUser(prev => ({ ...prev, ...userData }));\r\n    }, [user]);\r\n\r\n    return (\r\n        <AuthContext.Provider value={{\r\n            user,\r\n            loading,\r\n            isAuthenticated,\r\n            login,\r\n            logout,\r\n            hasRole,\r\n            hasAnyRole,\r\n            updateUser\r\n        }}>\r\n            {children}\r\n        </AuthContext.Provider>\r\n    );\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}